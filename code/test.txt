### README.md
```
Introduction

NOTE: Utilizing programming help tools like ChatGPT or Copilot, as well as installing additional packages, is strictly prohibited.

The test is divided into two parts, a refactoring part and an implementation part.
- The refactoring part is meant to test your ability to refactor code and apply clean code principles.
- The implementation part is meant to test your ability to reuse existing code and solve problems.

[Keep in mind acronyms such as SOLID, KISS, DRY and YAGNI.]

Areas of Screening

This candidate assessment screens for
1. Refactoring Skills: Ability to improve code structure and readability while adhering to clean code principles
2. System Architecture and Optimization Skills: in enhancing system performance, particularly through implementing caching strategies
3. Adaptability: Ability to work effectively with pre-existing codebases and adhere to set constraints.

Case Study (50 min)

You're joining a team tasked with enhancing a key component of a larger payment system. This segment, developed several years ago, has seen numerous hands in its maintenance, leading to a somewhat disorganized structure and unclear naming conventions. Additionally, the code lacks robust testing, and the existing tests are not particularly clear or effective.

A significant challenge is the system's performance limitations, partly due to its reliance on a slow database. The current setup uses a JSON file managed by Jackson, but for the sake of this scenario, think of it as a sluggish database. To address this, your team has decided to introduce a caching layer, aiming to minimize database calls and boost overall performance.

Another major focus is on refactoring the existing codebase. The goal here is to transform it into a more coherent, manageable, and developer-friendly structure. This revamp is essential for improving maintainability and facilitating more efficient future updates or modifications.
```

### CacheLimits.java
```
/**
 * @property maxItemsCount
 * Maximum count of items (*inclusive*) that this cache is allowed to contain
 */
public class CacheLimits {
    private final int maxItemsCount;

    public CacheLimits(int maxItemsCount) { this.maxItemsCount = maxItemsCount; }

    public int getMaxItemsCount() { return maxItemsCount; }
}
```

### Client.java
```
package com.speechify;

public class Client {
    private String id;
    private String name;

    public Client() {
    }

    public Client(String id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getId() { return id; }

    public void setId(String id) { this.id = id; }

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }
}
```

### ClientRepository.java
```
package com.speechify;

import ...

public class ClientRepository {
    private static final String DB_FILE = "db.json";
    private final ObjectMapper objectMapper;

    public ClientRepository() { this.objectMapper = new ObjectMapper(); }

    public CompletableFuture<Client> getById(String id) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                File dbFile = new File(DB_FILE);
                if (!dbFile.exists()) {
                    return null;
                }
                ObjectNode root = (ObjectNode) objectMapper.readTree(dbFile);
                ArrayNode clients = (ArrayNode) root.get("clients");
                for (int i = 0; i < clients.size(); i++) {
                    ObjectNode clientNode = (ObjectNode) clients.get(i);
                    if (clientNode.get("id").asText().equals(id)) {
                        Client client = new Client();
                        client.setId(clientNode.get("id").asText());
                        client.setName(clientNode.get("name").asText());
                        return client;
                    }
                }
                return null;
            } catch (IOException e) {
                return null;
            }
        });
    }

    public CompletableFuture<List<Client>> getAll() {
        return CompletableFuture.supplyAsync(() -> {
            try {
                File dbFile = new File(DB_FILE);
                if (!dbFile.exists()) {
                    return new ArrayList<>();
                }
                ObjectNode root = (ObjectNode) objectMapper.readTree(dbFile);
                ArrayNode clients = (ArrayNode) root.get("clients");
                List<Client> clientList = new ArrayList<>();
                for (int i = 0; i < clients.size(); i++) {
                    ObjectNode clientNode = (ObjectNode) clients.get(i);
                    Client client = new Client();
                    client.setId(clientNode.get("id").asText());
                    client.setName(clientNode.get("name").asText());
                    clientList.add(client);
                }
                return clientList;
            } catch (IOException e) {
                return new ArrayList<>();
            }
        });
    }
}
```

### LRUCache.java
```
package com.speechify;

/**
 * A Least Recently Used (LRU) cache is a type of cache that evicts the
 * when there is a need to constrain its size.
 *
 * For this particular implementation, the size constraint is set at CacheLimits
 * An item is considered accessed whenever `get`, or `set` methods are called
 * This LRU cache will achieve size constraint by checking the cache size
 * In the case where the cache has reached its limit, the item least recently
 * This removal process will not happen on a separate thread but in the calling
 * thus potentially blocking their return for a cleanup when deemed necessary
 *
 * Use the provided com.speechify.LRUCacheProviderTest in `src/test/java/LruCacheTest.java`
 * implementation.
 *
 * You may:
 * - Read online API references for Java standard library or JVM collections.
 * You must not:
 * - Read guides about how to code an LRU cache.
 */

public interface LRUCache<T> {
    T get(String key);

    void set(String key, T value);
}
```

### LRUCacheProvider.java
```
package com.speechify;

public class LRUCacheProvider {
    public static <T> LRUCache<T> createLRUCache(CacheLimits options) {
        throw new UnsupportedOperationException("Implement this function");
    }
}
```

### User.java
```
package com.speechify;

import java.time.LocalDate;

public class User {
    private String id;
    private Client client;
    private LocalDate dateOfBirth;
    private String email;
    private String firstname;
    private String surname;
    private boolean hasCreditLimit;
    private double creditLimit;

    public User() {
    }

    public User(String id, Client client, LocalDate dateOfBirth, String email, String firstname, String surname, boolean hasCreditLimit, double creditLimit) {
        this.id = id;
        this.client = client;
        this.dateOfBirth = dateOfBirth;
        this.email = email;
        this.firstname = firstname;
        this.surname = surname;
        this.hasCreditLimit = hasCreditLimit;
        this.creditLimit = creditLimit;
    }

    public String getId() { return id; }

    public void setId(String id) { this.id = id; }
}
```



Based on the provided image, here is the content of each file as accurately as possible. Note that the image shows multiple files open, but only partial content is visible for some files. I will transcribe the visible content for each file:

### 1. `UserService.java`
```java
public class UserService { no usages & Speechify Recruiting Bot

    public CompletableFuture<Boolean> addUser() { no usages & Speechify Recruiting Bot
    };

    public CompletableFuture<Boolean> updateUser(User user) { no usages & Speechify Recruiting Bot
        return CompletableFuture.supplyAsync(() -> {
            try {
                if (user == null) {
                    return false;
                }
                File dbFile = new File(DB_FILE);
                if (!dbFile.exists()) {
                    return false;
                }
                ObjectNode root = (ObjectNode) objectMapper.readTree(dbFile);
                ArrayNode users = (ArrayNode) root.get("users");

                // Find and update user
                for (int i = 0; i < users.size(); i++) {
                    ObjectNode userNode = (ObjectNode) users.get(i);
                    if (userNode.get("id").asText().equals(user.getId())) {
                        users.set(i, objectMapper.valueToTree(user));
                        objectMapper.writeValue(dbFile, root);
                        return true;
                    }
                }
                return false;
            } catch (IOException e) {
                return false;
            }
        });
    };

    public CompletableFuture<User> getUserByEmail(String email) { no usages & Speechify Recruiting Bot
        return CompletableFuture.supplyAsync(() -> {
            try {
                File dbFile = new File(DB_FILE);
                if (!dbFile.exists()) {
                    return null;
                }
                ObjectNode root = (ObjectNode) objectMapper.readTree(dbFile);
                ArrayNode users = (ArrayNode) root.get("users");
                for (int i = 0; i < users.size(); i++) {
                    ObjectNode userNode = (ObjectNode) users.get(i);
                    if (userNode.get("email").asText().equals(email)) {
                        return objectMapper.treeToValue(userNode, User.class);
                    }
                }
                return null;
            } catch (IOException e) {
                return null;
            }
        });
    };

    public CompletableFuture<List<User>> getAllUsers() { no usages & Speechify Recruiting Bot
        return CompletableFuture.supplyAsync(() -> {
            try {
                File dbFile = new File(DB_FILE);
                if (!dbFile.exists()) {
                    return new ArrayList<>();
                }
                ObjectNode root = (ObjectNode) objectMapper.readTree(dbFile);
                ArrayNode users = (ArrayNode) root.get("users");
                List<User> userList = new ArrayList<>();
                for (int i = 0; i < users.size(); i++) {
                    User user = objectMapper.treeToValue(users.get(i), User.class);
                    userList.add(user);
                }
                return userList;
            } catch (IOException e) {
                return new ArrayList<>();
            }
        });
    };

    public CompletableFuture<Boolean> addUser(User user) { no usages & Speechify Recruiting Bot
        return CompletableFuture.supplyAsync(() -> {
            try {
                User user = new User();
                user.setId(UUID.randomUUID().toString());
                user.setClient(client);
                user.setDateOfBirth(dateOfBirth);
                user.setEmail(email);
                user.setFirstName(firstname);
                user.setSurname(surname);

                // Set credit limit based on client
                if ("VeryImportantClient".equals(client.getName())) {
                    user.setHasCreditLimit(false);
                } else if ("ImportantClient".equals(client.getName())) {
                    user.setHasCreditLimit(true);
                    user.setCreditLimit(1000 * 2);
                } else {
                    user.setHasCreditLimit(true);
                    user.setCreditLimit(10000);
                }

                // Add user to database
                users.add(objectMapper.valueToTree(user));
                objectMapper.writeValue(dbFile, root);
                return true;
            } catch (IOException e) {
                return false;
            }
        });
    };
}
```
